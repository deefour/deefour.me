// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var color, colors, exec, getInfo, growl, logger, namespace, notify, os, spawn, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  _ref = require('child_process'), exec = _ref.exec, spawn = _ref.spawn;

  os = require('os');

  color = require('ansi-color');

  growl = require('growl');

  require('date-utils');

  notify = (function() {
    var counter, enabled, isMountainLion, tnBin;
    isMountainLion = os.platform() === 'darwin' && os.release().indexOf('12.') === 0;
    tnBin = '/Applications/terminal-notifier.app/Contents/MacOS/terminal-notifier';
    counter = 52910;
    enabled = false;
    if (isMountainLion) {
      exec("" + tnBin + " --help", function(error, stdout, stderr) {
        if (!(stderr.length > 0)) {
          return enabled = true;
        }
      });
    }
    return function(message, args, callback) {
      var proc, _ref1, _ref2, _ref3, _ref4;
      if (args == null) {
        args = {};
      }
      if (callback == null) {
        callback = function() {};
      }
      if (isMountainLion && enabled) {
        if (!message) {
          throw new Error('First argument is required in notification');
        }
        if ((_ref1 = args.title) == null) {
          args.title = (_ref2 = args.name) != null ? _ref2 : 'Terminal';
        }
        if ((_ref3 = args.groupId) == null) {
          args.groupId = counter += 1;
        }
        if ((_ref4 = args.bundleId) == null) {
          args.bundleId = 'com.apple.Terminal';
        }
        console.log([args.groupId, args.title, message, args.bundleId]);
        proc = spawn(tnBin, [args.groupId, args.title, message, args.bundleId]);
        proc.on('exit', function() {
          return callback();
        });
        return true;
      } else {
        return growl(message, args);
      }
    };
  })();

  colors = {
    error: 'red',
    warn: 'yellow',
    info: 'green',
    debug: 'blue'
  };

  getInfo = function(level) {
    var date, lvl;
    date = new Date().toFormat('DD MMM HH24:MI:SS');
    lvl = color.set(level, colors[level]);
    return "" + date + " - " + lvl + ":";
  };

  namespace = process.env.BRUNCH_DEBUG;

  logger = {
    isDebug: Boolean(namespace),
    errorHappened: false,
    notifications: true,
    debugNamespace: (function() {
      if (namespace) {
        if (namespace === '*') {
          return '*';
        } else {
          return namespace.split(',');
        }
      } else {
        return [];
      }
    })(),
    matchesDebugNamespace: function(current) {
      namespace = logger.debugNamespace;
      return namespace === '*' || __indexOf.call(namespace, current) >= 0;
    },
    log: function() {
      var args, info, level;
      level = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      info = getInfo(level);
      return process.nextTick(function() {
        if (level === 'error' || level === 'warn') {
          return console.error.apply(console, [info].concat(__slice.call(args)));
        } else {
          return console.log.apply(console, [info].concat(__slice.call(args)));
        }
      });
    },
    error: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (logger.notifications) {
        notify(args.join(' '), {
          title: 'Brunch error'
        });
      }
      logger.errorHappened = true;
      return logger.log.apply(logger, ['error'].concat(__slice.call(args)));
    },
    warn: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return logger.log.apply(logger, ['warn'].concat(__slice.call(args)));
    },
    info: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return logger.log.apply(logger, ['info'].concat(__slice.call(args)));
    },
    debug: function() {
      var args, namespace;
      namespace = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (logger.isDebug && logger.matchesDebugNamespace(namespace)) {
        return logger.log.apply(logger, ['debug'].concat(__slice.call(args)));
      }
    }
  };

  module.exports = Object.seal(logger);

}).call(this);
